# Простейшее приложение и установка SDKMAN

## Установка SDKMAN

Для установки различных SDK удобно использовать проект SDKMAN - https://sdkman.io/

Выполняем команду curl -s "https://get.sdkman.io" | bash для установки SDKMAN

Далее  /c/Users/User/.sdkman/bin/sdkman-init.sh чтобы можно было запускать командой sdk

**sdk ls** - просмотреть список всех доступных sdk

**sdk i java version** - установить версию Java

**sdk ls java** - просмотреть доступные и установленные версии Java

**sdk u java \<version>** - сменить используемую версию Java.


Зависимости и pom-файл

###parent
**spring-boot-starter-parent** - оборачивает всю мощь Spring для легкого использования

###dependency
**spring-boot-starter-web** - позволяет использовать web

**spring-boot-starter-thymeleaf** - шаблонизатор

**spring-boot-devtools** - позволяет быстро перезагружать контейнер приложения при внесении изменений.

## Controller-фаил
**@RequestParam** - ожидается на вход параметр с определенным именем и дефолтным значением

**Model** - "хранилище данных", которые нужно вернуть пользователю.

**return fileName** - метод маппинга возвращает имя файла, который нужно отобразить.

## HTML-файл

Шаблоны **thymeleaf** - тот же **HTML** с подключенным **xml-namespace** 

## Application - файл
**@SpringBootApplication** - добавляет функциональность Spring-boot: поиск контроллеров, файлов подключения к БД, поднимают приложения и так далее.

## Замена Thymeleaf на Mustache

* Заменяем в pom-файле зависимость **spring-boot-starter-mustache**
* Переименовываем html-файл в mustache-файл.

# Подключение БД

## Зависимости и pom-файл

**spring-boot-starter-data-jpa** - без этого ничего работать не будет. Java Persistence API.

**postgresql** - работа с БД Postgresql 

## Properties

Создаем файл **application.properties**

Указываем параметры подключения к БД.

**spring.jpa.generate-ddl=true** - создание БД мы берём на себя, а структуру создаёт и обслуживает Spring. Такие операции, как создание новых объектов для хранения в БД, добавление полей, переименование и т.д.

## Создаём сущности

Создаём package **domain** в котором будут храниться все файлы для сущностей, чтобы не искать их по всему коду.

**@Entity** - указывает, что это не просто кусок кода, а сущность, которую нужно сохранить в БД

**@Id** - данное поле является идентификатором в БД

**@GeneratedValue(strategy = GenerationType.AUTO)** - Spring и БД сами выбирают способ генерации Id.

## Репозиторий

Создаём **package repository** в котором будут храниться репозитории.

Внутри пакета создаём интерфейс **MessageRepo**, который наследуется от **CrudRepository**, интерфейс предоставляет методы, реализующие наиболее часто используемые операции с БД.

**@Autowired** - подключаем репозиторий (создаётся объект (бин), подключаются зависимости). Лучше зависимость делать через конструктор.

**@RequestParam** - значения переменных получаются либо из <form\>, либо из URL. **Spring** пытается выдернуть поля по имени переменной, если не указано её имя в поле name.

В классе, помеченном аннотацией @Entity для правильной работы **Spring** всегда необходимо создавать пустой конструктор.

Сохраняется объект в БД с помощью метода save у экземпляра объекта **MessageRepo**.

Добавляем в **MessageRepo** метод **findByTag** имя метода должно быть задано в соответствии с шаблоном из документации **Spring JPA**, чтобы **Spring** смог его сгенерировать автоматически. 

**Примечание 1:** в main.mustache в форме на добавление нужно прописать action = "/", чтобы не падал сценарий после фильтрации, при добавлении новой записи. Так как после указания фильтра URL остаётся с filter и не знает как себя вести при добавлении новой записи.

**Примечание 2:** в post-методе сохранения новой записи указываем return "redirect:/", это позволяет не укладывать список сообщений в model и пересылать в main.mustache, а сразу происходит переход на маппинг / и там уже выводит список всех сообщений после добавления новой записи.  

# Spring Security

## Конфиг web-слоя

Создаём страницу в корне, с которой будте переход по ссылке на **main**

Далее создаём package **config** и класс **MVCConfig** - класс, который содержит конфигурацию web-слоя. В методе addViewControllers раздаются контроллеры всем страницам, оставляем только контроллер авторизации. Spring сам предоставляет логику авторизации и шаблон страницы, мы берем только логику. Контроллер нужно активизировать.

Добавляем зависимость **spring-boot-starter-security**

## Конфиг путей с общим доступом

В классе **WebSecurityConfig** прописываем путь к странице с общим доступом, пусть к стронице логина и логаут.

Бин **userDetailService** нужен только для отладки, создаёт в памяти менеджер, который обслуживает учётные записи. Здесь задаётся юзер и пароль для отладки.

## Добавляем страницу login

Создаём файл login.mustache с формой для логина.

Добавляем кнопку logout на страницу main.mustache.

## CSRF

CSRF позволяет избежать хаккерских атак. Обращаться к серверу, производить на нём действия могут только те страницы, у которых есть токкен выданный этим сервером.

В случае с Thymeleaf Spring сам незаметно подсовывает нужный функционал. Так как мы работем с mustache нам необходимо выполнить ряд настроек.

Добавляем в application.properties **spring.mustache.expose-request-attributes=true** - включает дополнительные атрибуты для mustache, SpringMVC будет отдавать доплнительные параметры и они будут переходить в шаблоны.

На странице main и логина добавляем скрытое поле с токкеном ко всем формам. Без данного поля выполнение форм будет игнорироваться.

## Авторизация в БД

Производить авторизацию in memory не удобно, каждого нового пользователя нужно будет заводить руками. Добавим возможность самостоятельной авторизации. 

Добавим объект **User** и enum **Role** в package **Domain**. Имя таблицы **usr** так как Postgresql не любит, когда таблицы называются так же как и внутренние переменные.

Создаём **Set<Role\> roles** - роли у пользователя. 

Вводим аннотацию **@ElementCollection(targetClass = Role.class, fetch = FetchType.EAGER)** позволяет избавиться от головной боли по созданию дополнительной таблицы для хранения Enum. Fetch - параметр влияет нужно ли подгружать вспомогательную значения при загрузке основной сущности.

**@CollectionTable(name = "user_role", joinColumns = @JoinColumn(name = "user_id"))** - показывает, что данное поле будет храниться в отдельной таблицы, для которой мы не описывали мэппинг. **@JoinColumn** - таблица будет соединяться с текущей через поле user id.

**@Enumerated(EnumType.STRING)** - показываем, что это enum и храниться он будет в виде строки.

## Настраиваем WebSecurityConfig

Удаляем метод **userDetailsService()** так как теперь пароли будут храниться в БД. Для этого переопределяем метод **configure(AuthenticationManagerBuilder auth)**

Бин dataSourse нужен для того, чтобы менеджер мог ходить в БД.

**passwordEncoder** - будем хранить ключи в зашифрованном виде.

**usersByUsernameQuery()** - запрос к БД, необходим для того, чтобы система могла найти пользователя по его имени.

**authoritiesByUsernameQuery** - позволяет получить Spring список пользователей с их ролями.

## Добавляем форму регистрации

Создаём файл registrarion.mustache и добавляем на странице login ссылку на страницу регистрации.

Добавим контроллер для регистрации. В посмаппинге необходимо найти юзера, для этого создаём ещё один репозиторий, наследующий **JpaRepository**. Он содержит в себе один метод **User findByUsername(String username);**.

Делаем Autowired юзер репозитория в контроллер регистрации.

**Collections.singleton(Role.USER)** - short-cut, создаёт set с одним единственным значением.

И сохраняем пользователя в репозиторий.

Так же необходимо в классе WebSecurityConfig указать, что допустим путь /registration.

# Spring Boot Jpa (Hibernate): добавляем связи между таблицами базы данных (one to many)

Добавим к сообщение поле author типа User.

Сделаем чтобы User implements UserDetails.

Переопределяем методы UserDetails, всем присваиваем true, так как мы не реализуем эту логику, а без true работать не будет. isEnable() по смыслу как isActive().

getAuthorities() пусть возвращает getRoles(), только нужно сделать чтобы Role extends GrantedAuthority.

Добавляем в package **service** класс UserService для получения пользователей из БД.

В класс User добавляем поле author типа User, и делаем мэппинг ManyToOne. Добавляем вывод автора на странице main.

Необходимо ввести дополнительный метод getAuthorName в класс Message, метод будет передавать имя автора, если оно есть, либо дефолтное значение. Так же на странице main нужно прописать поле как {{authorName}}

## Spring Boot Freemarker: подключаем шаблонизатор Freemarker

Переезжаем на Freemarker.

**spring-boot-starter-freemarker** - заменяем mustache на freemaker

Создаём макросы, вставляем импорты и доступ к переменным в стоответствии с синтаксивом freemaker.

В MainController уберём логику фильтра из метода Post, и добавим проверку в Get метод с маппингом главной страницы. При этом параметр filter передаём как необязательный. Так же можем заменить model на класс Model.

**public String main(@RequestParam(required = false, defaultValue = "") String filter, Model model)**

Так же на форме main.ftlh меняем метод на форме фильтрации на get и action="/main" и удаляем csrf-токкен. Токкен нужен только для post-методов.

## Spring Boot Security: добавляем панель администратора и роли пользователей, ограничиваем доступ

## Spring Boot MVC: загрузка файлов на сервер и раздача статики

Добавим в properties директорию, в которой будут храниться файлы <br>
**upload.path=/home/dru/dev/sweater/uploads** <br>
файлы так же можно хранить на ftp, отдавать на откуп http, или хранить на Amazon.

Добавим в форму возможность загрузки файла и изменим её свойства <br>
**<form method="post" action="main" enctype="multipart/form-data"\>**<br>
**<input type="file" name="file"\>**

В классе MVCConfig необходимо переопределить метод **addResourceHandlers** для того, чтобы при обращении к серверу с запросом файла по определенному пути перенаправлялось в другую директорию (в нашем случае uploadPath).

В MainController в Post метод необходимо добавить действия с file который приходит при отправке формы. Если поле file существует и !file.getOriginalFilename().isEmpty(), то выбранную картинку необходимо загрузить в папку uploadPath. При этом проверяется существует она или нет (если нет, то создаём новую папку). Каждому файлу присваивается уникальное имя с помощью UUID и его первоначального имени, чтобы избежать коллизий.

В файл main.ftlh необходимо добавить контейнер для рисунка, если в записи БД есть название файла, то картинка будет отображена на экране.

<#if message.filename??><br>
<img src="/img/${message.filename}"\><br>
</#if>

Создадим папку static и в ней файл style.css с цветом текста и добавим ссылку на этот файл в файл общих настроек html **common.ftlh**

Нужно настроить мэппинг, чтобы статические файлы раздавались без авторизации, для этого в классе WebSecurityConfig добавим путь в .antMatchers("/", "/registration", "/static").permitAll()

Так же добавим изменения в MVCConfig в метод **addResourceHandlers** - ещё один registry/





















