# Простейшее приложение и установка SDKMAN

## Установка SDKMAN

Для установки различных SDK удобно использовать проект SDKMAN - https://sdkman.io/

Выполняем команду curl -s "https://get.sdkman.io" | bash для установки SDKMAN

Далее  /c/Users/User/.sdkman/bin/sdkman-init.sh чтобы можно было запускать командой sdk

**sdk ls** - просмотреть список всех доступных sdk

**sdk i java version** - установить версию Java

**sdk ls java** - просмотреть доступные и установленные версии Java

**sdk u java \<version>** - сменить используемую версию Java.


Зависимости и pom-файл

###parent
**spring-boot-starter-parent** - оборачивает всю мощь Spring для легкого использования

###dependency
**spring-boot-starter-web** - позволяет использовать web

**spring-boot-starter-thymeleaf** - шаблонизатор

**spring-boot-devtools** - позволяет быстро перезагружать контейнер приложения при внесении изменений.

## Controller-фаил
**@RequestParam** - ожидается на вход параметр с определенным именем и дефолтным значением

**Model** - "хранилище данных", которые нужно вернуть пользователю.

**return fileName** - метод маппинга возвращает имя файла, который нужно отобразить.

## HTML-файл

Шаблоны **thymeleaf** - тот же **HTML** с подключенным **xml-namespace** 

## Application - файл
**@SpringBootApplication** - добавляет функциональность Spring-boot: поиск контроллеров, файлов подключения к БД, поднимают приложения и так далее.

## Замена Thymeleaf на Mustache

* Заменяем в pom-файле зависимость **spring-boot-starter-mustache**
* Переименовываем html-файл в mustache-файл.

# Подключение БД

## Зависимости и pom-файл

**spring-boot-starter-data-jpa** - без этого ничего работать не будет. Java Persistence API.

**postgresql** - работа с БД Postgresql 

## Properties

Создаем файл **application.properties**

Указываем параметры подключения к БД.

**spring.jpa.generate-ddl=true** - создание БД мы берём на себя, а структуру создаёт и обслуживает Spring. Такие операции, как создание новых объектов для хранения в БД, добавление полей, переименование и т.д.

## Создаём сущности

Создаём package **domain** в котором будут храниться все файлы для сущностей, чтобы не искать их по всему коду.

**@Entity** - указывает, что это не просто кусок кода, а сущность, которую нужно сохранить в БД

**@Id** - данное поле является идентификатором в БД

**@GeneratedValue(strategy = GenerationType.AUTO)** - Spring и БД сами выбирают способ генерации Id.

## Репозиторий

Создаём **package repository** в котором будут храниться репозитории.

Внутри пакета создаём интерфейс **MessageRepo**, который наследуется от **CrudRepository**, интерфейс предоставляет методы, реализующие наиболее часто используемые операции с БД.

**@Autowired** - подключаем репозиторий (создаётся объект (бин), подключаются зависимости). Лучше зависимость делать через конструктор.

**@RequestParam** - значения переменных получаются либо из <form\>, либо из URL. **Spring** пытается выдернуть поля по имени переменной, если не указано её имя в поле name.

В классе, помеченном аннотацией @Entity для правильной работы **Spring** всегда необходимо создавать пустой конструктор.

Сохраняется объект в БД с помощью метода save у экземпляра объекта **MessageRepo**.

Добавляем в **MessageRepo** метод **findByTag** имя метода должно быть задано в соответствии с шаблоном из документации **Spring JPA**, чтобы **Spring** смог его сгенерировать автоматически. 

**Примечание 1:** в main.mustache в форме на добавление нужно прописать action = "/", чтобы не падал сценарий после фильтрации, при добавлении новой записи. Так как после указания фильтра URL остаётся с filter и не знает как себя вести при добавлении новой записи.

**Примечание 2:** в post-методе сохранения новой записи указываем return "redirect:/", это позволяет не укладывать список сообщений в model и пересылать в main.mustache, а сразу происходит переход на маппинг / и там уже выводит список всех сообщений после добавления новой записи.  

# Spring Security

## Конфиг web-слоя

Создаём страницу в корне, с которой будте переход по ссылке на **main**

Далее создаём package **config** и класс **MVCConfig** - класс, который содержит конфигурацию web-слоя. В методе addViewControllers раздаются контроллеры всем страницам, оставляем только контроллер авторизации. Spring сам предоставляет логику авторизации и шаблон страницы, мы берем только логику. Контроллер нужно активизировать.

Добавляем зависимость **spring-boot-starter-security**

## Конфиг путей с общим доступом

В классе **WebSecurityConfig** прописываем путь к странице с общим доступом, пусть к стронице логина и логаут.

Бин **userDetailService** нужен только для отладки, создаёт в памяти менеджер, который обслуживает учётные записи. Здесь задаётся юзер и пароль для отладки.

## Добавляем страницу login

Создаём файл login.mustache с формой для логина.

Добавляем кнопку logout на страницу main.mustache.

## CSRF

CSRF позволяет избежать хаккерских атак. Обращаться к серверу, производить на нём действия могут только те страницы, у которых есть токкен выданный этим сервером.

В случае с Thymeleaf Spring сам незаметно подсовывает нужный функционал. Так как мы работем с mustache нам необходимо выполнить ряд настроек.

Добавляем в application.properties **spring.mustache.expose-request-attributes=true** - включает дополнительные атрибуты для mustache, SpringMVC будет отдавать доплнительные параметры и они будут переходить в шаблоны.

На странице main и логина добавляем скрытое поле с токкеном ко всем формам. Без данного поля выполнение форм будет игнорироваться.

## Авторизация в БД

Производить авторизацию in memory не удобно, каждого нового пользователя нужно будет заводить руками. Добавим возможность самостоятельной авторизации. 

Добавим объект **User** и enum **Role** в package **Domain**. Имя таблицы **usr** так как Postgresql не любит, когда таблицы называются так же как и внутренние переменные.

Создаём **Set<Role\> roles** - роли у пользователя. 

Вводим аннотацию **@ElementCollection(targetClass = Role.class, fetch = FetchType.EAGER)** позволяет избавиться от головной боли по созданию дополнительной таблицы для хранения Enum. Fetch - параметр влияет нужно ли подгружать вспомогательную значения при загрузке основной сущности.





