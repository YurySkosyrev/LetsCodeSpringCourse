# Sweeter

## Учебное web-приложение на Spring boot 2
**Spring Boot** создан для того, чтобы сделать создание готовых к работе приложений и сервисов на Spring простым, без чрезмерных усилий. Spring Boot это субъективный взгляд на платформу Spring, который позволяет как новичкам так и опытным пользователям Spring-а найти все нужное. При помощи Boot-а можно создавать stand-alone приложения, запускаемые как ‘java -jar’ или распространяемые более традиционным WAR форматом.

Структура приложения (его компонентов) основана на архитектуре MVC

**MVC** — это схема разделения данных приложения и управляющей логики на три отдельных компонента: модель, представление и контроллер — таким образом, что модификация каждого компонента может осуществляться независимо.

- **Модель (Model)** предоставляет данные и реагирует на команды контроллера, изменяя свое состояние.
- **Представление (View)** отвечает за отображение данных модели пользователю, реагируя на изменения модели.
- **Контроллер (Controller)** интерпретирует действия пользователя, оповещая модель о необходимости изменений.

В данном приложении нет FrontController или Facade, нужный контроллер выбирается по endpoint.

## Модель (Model)

Model может предоставлять атрибуты для визуалиации представлений (View)

Добавление атрибута с именем и значением:
	
	model.addAttribute("page", page)

## Представление (View)

Для формирования HTML-страниц представления используется шаблонизатор **Apach FreeMaker**.

**Apache FreeMarker** — это механизм шаблонов: библиотека Java для генерации текстового вывода (HTML-страницы, xml, файлы конфигурации, исходный код и.т.д. На вход подается шаблон, например html в котором есть специальные выражения, подготавливаются данные соответствующие этим выражением, а Freemarker динамически вставляет эти данные и получается динамически заполненный документ.

### Макросы

В freemarker есть поддержка макросов, это очень удобная и сильная его сторона и использовать ее просто необходимо.

Пример:

    <#macro textInput id value="">
    	<input type="text" id="${id}" value="${value}">
	</#macro>

Это макрос с именем **textInput** и параметрами **id** (он обязательный) и **value** (он не обязательный, т.к. имеет значение по умолчанию). Далее идет его тело и использование входных параметров. В шаблоне файл с макросами подключается так:

	<#import "ui.ftl" as ui/>

Из шаблона макрос вызывается так:

	<@ui.textInput id="name" value="${name}"/>

Где ui это алиас который указали при подключении, ${name} переменная в модели, далее через алиас ссылаемся на имя макроса textInput и указываем его параметры, как минимум обязательные. 

## Контроллеры (Controllers)

**MainController.java** - контроллер обрабатывает запросы, связанные с greeting страницей, и основными действиями с сообщениями.


### Аннотации
**@PathVariable** - ожидает в составе URL значение аннотируемой переменной.

    @PostMapping("/user-messages/{user}")
	public String method(
    		@PathVariable(name = "user") Long user
	)

**@RequestParam(required = false, defaultValue = "") String filter** - в URL будет необязательный параметр filter, имеющий дефолтное значение ""

    URL: http://localhost:8090/main?filter=exTag

**@AuthenticationPrincipal** - получаем пользователя в качестве параметра

**@PageableDefault(sort = {"id"}, direction = Sort.Direction.DESC)** - управление сортировкой объекта Pageable

**@Valid** - валидация передаваемого экземпляра класса согласно аннотациям в самом классе. Ошибки складываются в BindingResult, эту переменную лучше располагать до Model иначе ошибки будут сыпаться во View.


### **Пагинация**
Когда записей в БД очень много их отображение на странице грузится очень долго и пользователю бывает необходимо прочитать только часть этих данных. Для этого существует пагинация - постраничный выбор данных.


В Spring для пагинации есть интерфейс **Page**. Для использования паганации необходимо передать в методы репозитория аргумент типа **Pageable** и получить коллекцию нужного типа

    Page <Message> page = messageRepo.findAll(pageable, user)

Инстанс типа **Pageable** ожидает **RequestParams**: 
+ **page** - номер страницы 
+ **size** - число страниц 
+ **sort** - сортировка 

### **Добавление сообщения**

Сообщение, приходящие с Post-запросом валидируется благодаря аннотации @Value и аннотациям валидации @NotBlanc, @Length в классе Message, в них же указываются текст ошибки. 

Если есть ошибки, они записываются в переменную класса BindingResult, из которой формируется Map - "полеError" - "текст ошибки". Эта мапа передаётся в model как и сообщение, чтобы ввод сохранился в полях input формы. В представлении в тегах input отслеживается наличие переменных вида "fieldError" и они отображаются как подписи к ошибкам ввода. 

При успешной валидации сообщение удаляется из model и сохраняется с помощью соответствующего сервиса. Далее получаем в Page<> обновлённый список сообщений и url для pager и вызываем представление main.

Загрузка файлов происходит с помощью класса MultipartFile с проверкой существования файла, существования директории для сохранения и присвоения уникального имени файла с добавлением к оригинальному имени UUID. Экземпляр класса файл связывается с нужным файлом с помощью аннотации @RequestParam("file").




